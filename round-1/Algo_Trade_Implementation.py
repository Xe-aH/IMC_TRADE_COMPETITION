# -*- coding: utf-8 -*-
"""AlgoTradingSim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MA1yWiagM3kq9UsdivCOGPlhO0szCk1D
"""

from datamodel import OrderDepth, TradingState, Order
from typing import List
import pandas as pd

class Trader:

    def run(self, state: TradingState):
        """
        Main method to execute trading strategy.

        Parameters:
        - state: TradingState object containing market data and current positions.

        Returns:
        - result: Dictionary of orders to be executed for each product.
        - conversions: Placeholder for any currency conversions (not used here).
        - traderData: Placeholder for any additional data (not used here).
        """
        result = {}  # Dictionary to store orders for each product

        # Define position limits for each product
        position_limits = {
            'RAINFOREST_RESIN': 50,
            'KELP': 50,
            'SQUID_INK': 50
        }

        # Iterate over each product in the market
        for product, order_depth in state.order_depths.items():
            orders: List[Order] = []  # List to store orders for the current product

            # Calculate the acceptable price for the current product
            acceptable_price = self.calculate_acceptable_price(product, state)

            # Get the current position for the product
            current_position = state.position.get(product, 0)

            # Process sell orders (asks)
            for ask_price, ask_volume in order_depth.sell_orders.items():
                # Check if the ask price is lower than the acceptable price
                # and if buying won't exceed position limits
                if ask_price < acceptable_price and current_position + ask_volume <= position_limits[product]:
                    # Create a buy order (negative volume indicates buying)
                    orders.append(Order(product, ask_price, -ask_volume))
                    # Update current position
                    current_position += ask_volume

            # Process buy orders (bids)
            for bid_price, bid_volume in order_depth.buy_orders.items():
                # Check if the bid price is higher than the acceptable price
                # and if selling won't exceed position limits
                if bid_price > acceptable_price and current_position - bid_volume >= -position_limits[product]:
                    # Create a sell order (negative volume indicates selling)
                    orders.append(Order(product, bid_price, -bid_volume))
                    # Update current position
                    current_position -= bid_volume

            # Store the orders for the current product in the result dictionary
            result[product] = orders

        # Placeholder values for additional data
        traderData = "SAMPLE"
        conversions = 0

        # Return the result, conversions, and traderData
        return result, conversions, traderData

    def calculate_acceptable_price(self, product: str, state: TradingState) -> float:
        """
        Calculate the acceptable price for a product based on market data.

        Parameters:
        - product: The name of the product.
        - state: TradingState object containing market data.

        Returns:
        - Acceptable price as a float.
        """
        # Get the order depth for the product
        order_depth = state.order_depths[product]

        # Combine all sell and buy prices into a single list
        all_prices = list(order_depth.sell_orders.keys()) + list(order_depth.buy_orders.keys())

        # If there are no prices, return 0
        if not all_prices:
            return 0

        # Convert the list of prices into a pandas Series for analysis
        price_series = pd.Series(all_prices)

        # Calculate acceptable price based on product type
        if product == 'RAINFOREST_RESIN':
            # Use the mean price for stable products
            return price_series.mean()

        elif product == 'KELP':
            # Use both short-term and long-term moving averages for Kelp
            short_window = 7
            long_window = 15

            if len(price_series) >= long_window:
                short_ma = price_series.rolling(window=short_window).mean().iloc[-1]
                long_ma = price_series.rolling(window=long_window).mean().iloc[-1]
                #print(f"Kelp Short MA: {short_ma}, Long MA: {long_ma}")
                return (short_ma + long_ma) / 2
            else:
                return price_series.mean()

        elif product == 'SQUID_INK':
            # Use the mean price for products with potential patterns
            return price_series.mean()

        # Default return value if no conditions are met
        return 0